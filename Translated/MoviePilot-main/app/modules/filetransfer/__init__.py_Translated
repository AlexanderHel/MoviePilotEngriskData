"文件转移": "File transfer"
":param path:  文件路径": ":param path:   File path"
":param meta: 预识别的元数据，仅单文件转移时传递": ":param meta:  Pre-identified metadata， Passed on single file transfers only"
":param mediainfo:  识别的媒体信息": ":param mediainfo:   Identified media messages"
":param transfer_type:  转移方式": ":param transfer_type:   Migration pattern"
":param target:  目标路径": ":param target:   Target path"
":param episodes_info: 当前季的全部集信息": ":param episodes_info:  All episode information for the current season"
"# 获取目标路径": "#  Getting the target path"
"logger.error("未找到媒体库目录，无法转移文件")": "logger.error(" Media library catalog not found， Unable to transfer files")"
"message="未找到媒体库目录")": "message=" Media library catalog not found")"
"# 转移": "#  Divert or distract (attention etc)"
"使用系统命令处理单个文件": "Using system commands to process individual files"
":param file_item: 文件路径": ":param file_item:  File path"
":param target_file: 目标文件路径": ":param target_file:  Target file path"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
"# 转移": "#  Divert or distract (attention etc)"
"# 硬链接": "#  Hard link"
"# 软链接": "#  Soft link (computing)"
"# 移动": "#  Mobility"
"# 复制": "#  Make a copy of"
"根据文件名转移其他相关文件": "Transfer of other relevant documents by filename"
":param org_path: 原文件名": ":param org_path:  Original filename"
":param new_path: 新文件名": ":param new_path:  New filename"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
":param over_flag: 是否覆盖，为True时会先删除再转移": ":param over_flag:  Whether or not to override， Because ofTrue It will be deleted and then transferred."
"根据文件名转移对应字幕文件": "Transfer the corresponding subtitle file according to the file name"
":param org_path: 原文件名": ":param org_path:  Original filename"
":param new_path: 新文件名": ":param new_path:  New filename"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
"# 字幕正则式": "#  Regular formula for subtitles"
"r"|简[体中]?)[.\])])" \": "r"| Bamboo strips used for writing (old)[ Embodiment]?)[.\])])" \"
"r"|([\u4e00-\u9fa5]{0,3}[中双][\u4e00-\u9fa5]{0,2}[字文语][\u4e00-\u9fa5]{0,3})" \": "r"|([\u4e00-\u9fa5]{0,3}[ Both sides of the coin][\u4e00-\u9fa5]{0,2}[ Literary language][\u4e00-\u9fa5]{0,3})" \"
"r"|简体|简中|JPSC" \": "r"| Simplified chinese| Simple chinese|JPSC" \"
"r"|繁[体中]?)[.\])])" \": "r"| In great numbers[ Embodiment]?)[.\])])" \"
"r"|繁体中[文字]|中[文字]繁体|繁体|JPTC" \": "r"| Traditional chinese[ Writing style]| Center[ Writing style] Elaborate form| Elaborate form|JPTC" \"
"# 比对文件名并转移字幕": "#  Compare filenames and transfer subtitles"
"logger.debug(f"{org_dir} 目录下没有找到字幕文件...")": "logger.debug(f"{org_dir}  No subtitle files found in the directory...")"
"logger.debug("字幕文件清单：" + str(file_list))": "logger.debug(" List of subtitle files：" + str(file_list))"
"# 识别文件名": "#  Recognizing file names"
"# 识别字幕文件名": "#  Recognizing subtitle file names"
"# 匹配字幕文件名": "#  Match subtitle file name"
"# 兼容jellyfin字幕识别(多重识别), emby则会识别最后一个后缀": "#  Compatibilityjellyfin Subtitle recognition( Multiple identification), emby Then the last suffix will be recognized"
"# 通过对比字幕文件大小  尽量转移所有存在的字幕": "#  By comparing subtitle file sizes   Try to transfer all the subtitles present"
"".eng": ".英文",": "".eng": ". English (language)","
"".chi.zh-cn": ".简体中文",": "".chi.zh-cn": ". Simplified chinese","
"".zh-tw": ".繁体中文"": "".zh-tw": ". Traditional chinese""
"# 如果字幕文件不存在, 直接转移字幕, 并跳出循环": "#  If the subtitle file does not exist,  Direct transfer subtitles,  And jump out of the loop"
"logger.debug(f"正在处理字幕：{file_item.name}")": "logger.debug(f" Subtitles are being processed.：{file_item.name}")"
"logger.info(f"字幕 {file_item.name} {transfer_type}完成")": "logger.info(f" Subtitling {file_item.name} {transfer_type} Fulfillment")"
"logger.error(f"字幕 {file_item.name} {transfer_type}失败，错误码 {retcode}")": "logger.error(f" Subtitling {file_item.name} {transfer_type} Fail (e.g. experiments)， Error code {retcode}")"
"# 如果字幕文件的大小与已存在文件相同, 说明已经转移过了, 则跳出循环": "#  If the subtitle file is the same size as an existing file,  It means it's been transferred.,  Then jump out of the loop"
"logger.info(f"字幕 new_file 已存在")": "logger.info(f" Subtitling new_file  Pre-existing")"
"# 否则 循环继续 > 通过new_sub_tag_list 获取新的tag附加到字幕文件名, 继续检查是否能转移": "#  If not  The cycle continues >  Pass (a bill or inspection etc)new_sub_tag_list  Get newtag Attach to subtitle filename,  Keep checking to see if you can transfer"
"logger.info(f"字幕 {new_file} 出错了,原因: {reason}")": "logger.info(f" Subtitling {new_file}  There's been an error., Rationale: {reason}")"
"根据文件名转移对应音轨文件": "Transfer the corresponding track file according to its filename"
":param org_path: 原文件名": ":param org_path:  Original filename"
":param new_path: 新文件名": ":param new_path:  New filename"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
":param over_flag: 是否覆盖，为True时会先删除再转移": ":param over_flag:  Whether or not to override， Because ofTrue It will be deleted and then transferred."
"logger.debug(f"{dir_name} 目录下没有找到匹配的音轨文件")": "logger.debug(f"{dir_name}  No matching track file found in the directory")"
"logger.debug("音轨文件清单：" + str(pending_file_list))": "logger.debug(" Track file list：" + str(pending_file_list))"
"logger.warn(f"音轨文件已存在：{new_track_file}")": "logger.warn(f" Track file already exists：{new_track_file}")"
"logger.info(f"正在删除已存在的音轨文件：{new_track_file}")": "logger.info(f" Existing track files are being deleted：{new_track_file}")"
"logger.info(f"正在转移音轨文件：{track_file} 到 {new_track_file}")": "logger.info(f" Transferring track files：{track_file}  Until (a time) {new_track_file}")"
"logger.info(f"音轨文件 {file_name} {transfer_type}完成")": "logger.info(f" Audio track files {file_name} {transfer_type} Fulfillment")"
"logger.error(f"音轨文件 {file_name} {transfer_type}失败，错误码：{retcode}")": "logger.error(f" Audio track files {file_name} {transfer_type} Fail (e.g. experiments)， Error code：{retcode}")"
"logger.error(f"音轨文件 {file_name} {transfer_type}失败：{reason}")": "logger.error(f" Audio track files {file_name} {transfer_type} Fail (e.g. experiments)：{reason}")"
"转移整个文件夹": "Transferring an entire folder"
":param file_path: 原路径": ":param file_path:  Original path"
":param new_path: 新路径": ":param new_path:  New pathway"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
"logger.info(f"正在{transfer_type}目录：{file_path} 到 {new_path}")": "logger.info(f" In the process of (doing something or happening){transfer_type} Catalogs：{file_path}  Until (a time) {new_path}")"
"# 复制": "#  Make a copy of"
"logger.info(f"文件 {file_path} {transfer_type}完成")": "logger.info(f" File {file_path} {transfer_type} Fulfillment")"
"logger.error(f"文件{file_path} {transfer_type}失败，错误码：{retcode}")": "logger.error(f" File{file_path} {transfer_type} Fail (e.g. experiments)， Error code：{retcode}")"
"按目录结构转移目录下所有文件": "Transfer all files in a directory by directory structure"
":param src_dir: 原路径": ":param src_dir:  Original path"
":param target_dir: 新路径": ":param target_dir:  New pathway"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
"# 过滤掉目录": "#  Filter out directories"
"# 使用target_dir的父目录作为新的父目录": "#  Utilizationtarget_dir As the new parent directory of the"
"logger.warn(f"{new_file} 文件已存在")": "logger.warn(f"{new_file}  File already exists")"
"转移一个文件，同时处理其他相关文件": "Transferring a file， Simultaneous processing of other relevant documents"
":param file_item: 原文件路径": ":param file_item:  Original file path"
":param new_file: 新文件路径": ":param new_file:  New file path"
":param transfer_type: RmtMode转移方式": ":param transfer_type: RmtMode Migration pattern"
":param over_flag: 是否覆盖，为True时会先删除再转移": ":param over_flag:  Whether or not to override， Because ofTrue It will be deleted and then transferred."
"logger.warn(f"文件已存在：{new_file}")": "logger.warn(f" File already exists：{new_file}")"
"logger.info(f"正在删除已存在的文件：{new_file}")": "logger.info(f" Existing files are being deleted：{new_file}")"
"logger.info(f"正在转移文件：{file_item} 到 {new_file}")": "logger.info(f" Transferring files：{file_item}  Until (a time) {new_file}")"
"# 创建父目录": "#  Creating a parent directory"
"logger.info(f"文件 {file_item} {transfer_type}完成")": "logger.info(f" File {file_item} {transfer_type} Fulfillment")"
"logger.error(f"文件 {file_item} {transfer_type}失败，错误码：{retcode}")": "logger.error(f" File {file_item} {transfer_type} Fail (e.g. experiments)， Error code：{retcode}")"
"# 处理其他相关文件": "#  Processing of other relevant documents"
"根据设置并装媒体库目录": "Based on the setup and installation of the media library directory"
":param mediainfo: 媒体信息": ":param mediainfo:  Media information"
":target_dir: 媒体库根目录": ":target_dir:  Media library root directory"
"# 电影": "#  Cinematic"
"# 目的目录加上类型和二级分类": "#  Purpose directory plus type and secondary categorization"
"# 电视剧": "#  Dramas"
"# 动漫": "#  Cartoons and comics"
"# 电视剧": "#  Dramas"
"# 目的目录加上类型和二级分类": "#  Purpose directory plus type and secondary categorization"
"识别并转移一个文件或者一个目录下的所有文件": "Identify and move a file or all files in a directory"
":param in_path: 转移的路径，可能是一个文件也可以是一个目录": ":param in_path:  Paths of transfer， May be a file or a directory"
":param in_meta：预识别元数据": ":param in_meta： Pre-identified metadata"
":param mediainfo: 媒体信息": ":param mediainfo:  Media information"
":param target_dir: 媒体库根目录": ":param target_dir:  Media library root directory"
":param transfer_type: 文件转移方式": ":param transfer_type:  Document transfer method"
":param episodes_info: 当前季的全部集信息": ":param episodes_info:  All episode information for the current season"
":return: TransferInfo、错误信息": ":return: TransferInfo、 Error message"
"# 检查目录路径": "#  Checking directory paths"
"message=f"{in_path} 路径不存在")": "message=f"{in_path}  Path does not exist")"
"message=f"{target_dir} 目标路径不存在")": "message=f"{target_dir}  Target path does not exist")"
"# 媒体库目的目录": "#  Catalog of media library purposes"
"# 重命名格式": "#  Rename format"
"# 判断是否为文件夹": "#  Determine if a folder"
"# 转移整个目录": "#  Transferring an entire catalog"
"# 是否蓝光原盘": "#  Whether or not the original blu-ray disc"
"logger.info(f"{in_path} 是蓝光原盘文件夹")": "logger.info(f"{in_path}  It's the original blu-ray folder.")"
"# 目的路径": "#  Destination path"
"# 转移蓝光原盘": "#  Transferring the original blu-ray disc"
"logger.error(f"文件夹 {in_path} 转移失败，错误码：{retcode}")": "logger.error(f" File (paper) {in_path}  Transfer failure， Error code：{retcode}")"
"message=f"错误码：{retcode}",": "message=f" Error code：{retcode}","
"logger.info(f"文件夹 {in_path} 转移成功")": "logger.info(f" File (paper) {in_path}  The transfer was successful.")"
"# 返回转移后的路径": "#  Returns the path after the transfer"
"# 转移单个文件": "#  Transfer of individual documents"
"# 电视剧": "#  Dramas"
"logger.warn(f"文件 {in_path} 转移失败：未识别到文件集数")": "logger.warn(f" File {in_path}  Transfer failure： Number of unrecognized file sets")"
"message=f"未识别到文件集数",": "message=f" Number of unrecognized file sets","
"# 文件结束季为空": "#  End-of-file season is empty"
"# 文件总季数为1": "#  The total number of document seasons is1"
"# 文件不可能超过2集": "#  It is unlikely that the file will exceed2 Classifier for sections of a tv series e.g. episode"
"# 目的文件名": "#  Destination file name"
"# 判断是否要覆盖": "#  Determine whether to override"
"logger.info(f"目标文件已存在，但文件大小更小，将覆盖：{new_file}")": "logger.info(f" Target file already exists， But the file size is smaller， Will cover：{new_file}")"
"# 转移文件": "#  Transfer of documents"
"logger.error(f"文件 {in_path} 转移失败，错误码：{retcode}")": "logger.error(f" File {in_path}  Transfer failure， Error code：{retcode}")"
"message=f"错误码：{retcode}",": "message=f" Error code：{retcode}","
"logger.info(f"文件 {in_path} 转移成功")": "logger.info(f" File {in_path}  The transfer was successful.")"
"根据媒体信息，返回Format字典": "Based on media information， Come (or go) backFormat Dictionaries"
":param meta: 文件元数据": ":param meta:  Document metadata"
":param mediainfo: 识别的媒体信息": ":param mediainfo:  Identified media messages"
":param file_ext: 文件扩展名": ":param file_ext:  File extension"
":param episodes_info: 当前季的全部集信息": ":param episodes_info:  All episode information for the current season"
"# 获取集标题": "#  Get set title"
"# 标题": "#  Caption"
"# 原文件名": "#  Original filename"
"# 原语种标题": "#  Title in original language"
"# 识别名称": "#  Identifying name"
"# 年份": "#  Particular year"
"# 资源类型": "#  Resource type"
"# 特效": "#  Especially efficacious"
"# 版本": "#  Releases"
"# 分辨率": "#  Resolution (of a photo)"
"# 制作组/字幕组": "#  Production team/ Subtitling team"
"# 视频编码": "#  Video encoding"
"# 音频编码": "#  Audio encoding"
"# 季号": "#  Quarter"
"# 集号": "#  Bugle call"
"# 季集 SxxExx": "#  End of a season SxxExx"
"# 段/节": "#  Stage (of a process)/ Classifier for segments, e.g. lessons, train wagons, biblical verses"
"# 剧集标题": "#  Episode title"
"# 文件后缀": "#  File suffix"
"生成重命名后的完整路径": "Generate the full path after renaming"
"# 创建jinja2模板对象": "#  Establishjinja2 Template object"
"# 渲染生成的字符串": "#  Render the generated string"
"# 目的路径": "#  Destination path"
"根据目录查询其所在的媒体库目录，查询不到的返回输入目录": "Query the media library directory based on the directory it is in， Return to the input directory if you can't find it"
"# 目的路径，多路径以,分隔": "#  Destination path， Multipath, Segregation"
"logger.debug(f"计算媒体库路径时出错：{e}")": "logger.debug(f" Error calculating media library path：{e}")"
"计算一个最好的目的目录，有in_path时找与in_path同路径的，没有in_path时，顺序查找1个符合大小要求的，没有in_path和size时，返回第1个": "Calculate a best destination catalog， There arein_path Look for a match within_path Homologous， Hasn'tin_path Hour， Sequential search1 One size fits all， Hasn'tin_path Cap (a poem)size Hour， Return to section1 Classifier for individual things or people, general, catch-all classifier"
":param in_path: 源目录": ":param in_path:  Source catalog"
"# 目的路径，多路径以,分隔": "#  Destination path， Multipath, Segregation"
"# 只有一个路径，直接返回": "#  There's only one path.， Direct return"
"# 匹配有最长共同上级路径的目录": "#  Match directories with the longest common parent path"
"logger.debug(f"计算目标路径时出错：{e}")": "logger.debug(f" Error while calculating target path：{e}")"
"# 顺序匹配第1个满足空间存储要求的目录": "#  Sequential matching of the first1 Directories that meet space storage requirements"
"# 默认返回第1个": "#  Defaults to the first1 Classifier for individual things or people, general, catch-all classifier"
"判断媒体文件是否存在于本地文件系统": "Determine if a media file exists on the local file system"
":param mediainfo:  识别的媒体信息": ":param mediainfo:   Identified media messages"
":param itemid:  媒体服务器ItemID": ":param itemid:   Media serverItemID"
":return: 如不存在返回None，存在时返回信息，包括每季已存在所有集{type: movie/tv, seasons: {season: [episodes]}}": ":return:  Returns if not presentNone， Return information when present， Includes all existing episodes of each season{type: movie/tv, seasons: {season: [episodes]}}"
"# 目的路径": "#  Destination path"
"# 检查每一个媒体库目录": "#  Check every media library directory"
"# 媒体库路径": "#  Media library path"
"# 媒体分类路径": "#  Media classification path"
"# 重命名格式": "#  Rename format"
"# 相对路径": "#  Relative path"
"# 取相对路径的第1层目录": "#  Take the relative path of the first1 Top-level catalog"
"# 检查媒体文件夹是否存在": "#  Check if the media folder exists"
"# 检索媒体文件": "#  Retrieve media files"
"# 电影存在任何文件为存在": "#  Movie exists in any file as exists"
"logger.info(f"文件系统已存在：{mediainfo.title_year}")": "logger.info(f" The file system already exists：{mediainfo.title_year}")"
"# 电视剧检索集数": "#  Tv series search episodes"
"# 返回剧集情况": "#  Back to episode status"
"logger.info(f"{mediainfo.title_year} 文件系统已存在：{seasons}")": "logger.info(f"{mediainfo.title_year}  The file system already exists：{seasons}")"
"# 不存在": "#  Non-existent"
